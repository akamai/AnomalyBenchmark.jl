var documenterSearchIndex = {"docs":
[{"location":"index.html#AnomalyBenchmark.jl-Documentation","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.jl Documentation","text":"AnomalyBenchmark","category":"page"},{"location":"index.html#AnomalyBenchmark","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark","text":"AnomalyBenchmark.jl:\n\nJulia implementation of Numenta Anomaly Benchmark for Evaluating Algorithms for Streaming Anomaly Detection\n\nThis is a Julia implementation of Numenta's NAB Python package for Anomaly Benchmarking. The code is written from the ground up in Julia following the specifications of NAB.\n\n(Image: GH Build) (Image: Coverage Status) (Image: )\n\n\n\n\n\n","category":"module"},{"location":"index.html#Types","page":"AnomalyBenchmark.jl Documentation","title":"Types","text":"","category":"section"},{"location":"index.html","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.jl Documentation","text":"Modules=[AnomalyBenchmark]\nOrder=[:type]","category":"page"},{"location":"index.html#AnomalyBenchmark.Labeler","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.Labeler","text":"Object to get labels and compute the window around each anomaly.\n\nFields\n\ndata::DataFrame :    The whole data set with default columns timestamp.\n\nwindowSize::Float64 :    Estimated size of an anomaly window, as a ratio to the data set length.\n\nprobationaryPercent::Float64 :    The ratio of probationary period to the data set length.\n\nlabels::DataFrame :    Ground truth for each record.     For each record there should be a 1 or a 0.     A 1 implies this record is within an anomalous window.\n\nlabelIndices::AbstractArray{Int, 1} :    Indices of the true anomalies in labels\n\nwindows::AbstractArray{Tuple{DateTime,DateTime},1} :    All the window limits in tuple     form: (start time, end time).\n\nFunctions\n\nsetData::Function :    Set the dataset for Labeler.\n\nsetLabels::Function :    Set the ground true labels from timestamps of true anomalies.\n\ngetWindows::Function :    Call applyWindows and checkWindows.\n\napplyWindows::Function :    This takes all the true anomalies, and adds a standard window.     The window length is the class variable windowSize,     and the location is centered on the anomaly timestamp.\n\ncheckWindows::Function :    This takes the anomaly windows and checks for overlap with both each other     and with the probationary period. Overlapping windows are merged into a     single window. Windows overlapping with the probationary period are deleted.\n\nConstructors\n\nfunction Labeler(windowSize::Float64, probationaryPercent::Float64)\n\nArguments\n\nwindowSize::Float64 :    Estimated size of an anomaly window, as a ratio to the data set length.\n\nprobationaryPercent::Float64 :    The ratio of probationary period to the data set length.\n\nExamples\n\nLabeler(0.1, 0.15)\nAnomalyBenchmark.Labeler(0×0 DataFrames.DataFrame\n,0.1,0.15,0×0 DataFrames.DataFrame\n,Int64[],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n\n","category":"type"},{"location":"index.html#AnomalyBenchmark.Scorer","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.Scorer","text":"Object to score a data.\n\nFields\n\ndata::DataFrame :    The whole data set with default columns timestamp, label, index and alerttype.\n\nprobationaryPeriod::Int :    Row index after which predictions are scored.\n\ncostMatrix::Dict{AbstractString, Float64} :    The cost matrix for the profile with the following keys:\n\nTrue positive (tpWeight): detects the anomaly when the anomaly is present.\nFalse positive (fpWeight): detects the anomaly when the anomaly is absent.\nTrue Negative (tnWeight): does not detect the anomaly when the anomaly is absent.\nFalse Negative (fnWeight): does not detect the anomaly when the anomaly is present.\n\ntotalCount::Int :    The total count of labels.\n\ncounts::Dict{AbstractString, Int} :    The counts of tp, fp, tn and fn. Only predictions after probationaryPeriod are counted.\n\nscore::Float64 :    The score of the anomaly detection algorithm results.\n\nnormalizedScore::Float64 :    The normalized score of the anomaly detection algorithm     such that the maximum possible is 100.0 (i.e. the perfect detector), and     a baseline of 0.0 is determined by the \"null\" detector (which makes no detections).\n\nlen::Int :    The total count of predictions.\n\nwindows::Vector{Window} :    The list of windows for the data.\n\nwindowLimits::Vector{Tuple{DateTime,DateTime}} :    All the window limits in tuple     form: (start time, end time).\n\nFunctions\n\ngetWindows::Function :    Create list of windows for the data.\n\ngetAlertTypes::Function :    For each record, decide whether it is a tp, fp, tn, or fn. Populate     counts dictionary with the total number of records in each category.\n\ngetScore::Function :    Score the entire data and return a single floating point score.\n\ngetClosestPrecedingWindow::Function :    Given a record index, find the closest preceding window.\n\nnormalizeScore::Function :    Normalize the detectors' scores according to the baseline defined by the null detector.\n\nConstructor\n\nScorer(\n        timestamps::Vector{DateTime},\n        predictions::AbstractVector{<:Integer},\n        labels::AbstractVector{<:Integer},\n        windowLimits::Vector{Tuple{DateTime,DateTime}},\n        costMatrix::Dict{<:AbstractString, Float64},\n        probationaryPeriod::Int\n    )\n\nArguments\n\ntimestamps::Vector{DateTime} :    Timestamps in the data.\n\npredictions::AbstractVector{<:Integer} :    Detector predictions of whether each record is anomalous or not.     predictions[1:probationaryPeriod-1] are ignored.\n\nlabels::AbstractVector{Integer} :    Ground truth for each record.     For each record there should be a 1 or a 0.     A 1 implies this record is within an anomalous window.\n\nwindowLimits::Vector{Tuple{DateTime,DateTime}} :    All the window limits in tuple     form: (start time, end time).\n\ncostMatrix::Dict{AbstractString, Float64} :    The cost matrix for the profile with the following keys:\n\nTrue positive (tpWeight): detects the anomaly when the anomaly is present.\nFalse positive (fpWeight): detects the anomaly when the anomaly is absent.\nTrue Negative (tnWeight): does not detect the anomaly when the anomaly is absent.\nFalse Negative (fnWeight): does not detect the anomaly when the anomaly is present.\n\nprobationaryPeriod::Int :    Row index after which predictions are scored.\n\nExamples\n\ntimestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict{AbstractString, Float64}(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\nAnomalyBenchmark.Scorer(5×4 DataFrames.DataFrame\n│ Row │ timestamp           │ label │ index │ alerttype │\n├─────┼─────────────────────┼───────┼───────┼───────────┤\n│ 1   │ 2017-01-01T00:00:00 │ 0     │ 1     │ \"tn\"      │\n│ 2   │ 2017-01-02T00:00:00 │ 1     │ 2     │ \"tp\"      │\n│ 3   │ 2017-01-03T00:00:00 │ 0     │ 3     │ \"tn\"      │\n│ 4   │ 2017-01-04T00:00:00 │ 0     │ 4     │ \"tn\"      │\n│ 5   │ 2017-01-05T00:00:00 │ 0     │ 5     │ \"fp\"      │,1,Dict(:tpWeight=>1.0,:fnWeight=>1.0,:fpWeight=>1.0),5,\nDict{AbstractString,Int64}(\"tp\"=>1,\"tn\"=>3,\"fn\"=>0,\"fp\"=>1),0.0,5,[AnomalyBenchmark.Window(1,2017-01-02T00:00:00,2017-01-03T00:00:00,2×4 DataFrames.DataFrame\n│ Row │ timestamp           │ label │ index │ alerttype │\n├─────┼─────────────────────┼───────┼───────┼───────────┤\n│ 1   │ 2017-01-02T00:00:00 │ 1     │ 2     │ \"tp\"      │\n│ 2   │ 2017-01-03T00:00:00 │ 0     │ 3     │ \"tn\"      │,[2,3],2,(anonymous function),(anonymous function))],(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n\n","category":"type"},{"location":"index.html#AnomalyBenchmark.Window","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.Window","text":"Immutable object to store a single window in a data. Each window represents a range of data points that is centered around a ground truth anomaly label.\n\nFields\n\nid::Int :    The identifier of the Window.\n\nt1::DateTime :    The start time of the Window.\n\nt2::DateTime :    The end time of the Window.\n\nwindow::DataFrame :    The data within the Window.\n\nindices::AbstractArray :    The indices of the Window in the data.\n\nlen::Int :    The length of the Window.\n\nFunctions\n\nrepr::Function :    String representation of Window. For debugging.\n\ngetFirstTruePositive::Function :    Get the index of the first true positive within a window.\n\nConstructor\n\nWindow(windowId::Int, limits::Tuple{DateTime, DateTime}, data::DataFrame)\n\nArguments\n\nwindowId::Int :    An integer id for the Window.\n\nlimits::Tuple{DateTime, DateTime} :    The start time and end time of the Window.\n\ndata::DataFrame :    The whole data set with default columns index and timestamp.\n\nExamples\n\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)\n)\nwindow = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)\nAnomalyBenchmark.Window(1234,2017-01-01T00:00:00,2017-01-02T00:00:00,2×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │,[1,2],2,(anonymous function),(anonymous function))\n\n\n\n\n\n","category":"type"},{"location":"index.html#Methods","page":"AnomalyBenchmark.jl Documentation","title":"Methods","text":"","category":"section"},{"location":"index.html","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.jl Documentation","text":"Modules=[AnomalyBenchmark]\nOrder=[:function]","category":"page"},{"location":"index.html#AnomalyBenchmark.applyWindows-Tuple{AnomalyBenchmark.Labeler}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.applyWindows","text":"Takes all the true anomalies, as calculated by combineLabels(), and adds a standard window.\n\nArguments\n\nlabeler::Labeler\n\nExamples\n\nlabeler = Labeler(0.1, 0.15)\ntrueAnomalies = [DateTime(2017, 1, 3)]\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)\n)\n\nlabeler.setData(data)\nlabeler.setLabels(trueAnomalies)\nlabeler.applyWindows()\n\njulia> labeler\nAnomalyBenchmark.Labeler(5×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n│ 3   │ 3     │ 2017-01-03T00:00:00 │\n│ 4   │ 4     │ 2017-01-04T00:00:00 │\n│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame\n│ Row │ timestamp           │ label │\n├─────┼─────────────────────┼───────┤\n│ 1   │ 2017-01-01T00:00:00 │ 0     │\n│ 2   │ 2017-01-02T00:00:00 │ 0     │\n│ 3   │ 2017-01-03T00:00:00 │ 1     │\n│ 4   │ 2017-01-04T00:00:00 │ 0     │\n│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.checkWindows-Tuple{AnomalyBenchmark.Labeler}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.checkWindows","text":"Takes the anomaly windows and checks for overlap with both each other and with the probationary period. Overlapping windows are merged into a single window. Windows overlapping with the probationary period are deleted.\n\nArguments\n\nlabeler::Labeler\n\nExamples\n\nlabeler = Labeler(0.1, 0.15)\ntrueAnomalies = [DateTime(2017, 1, 3)]\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)\n)\n\nlabeler.setData(data)\nlabeler.setLabels(trueAnomalies)\nlabeler.applyWindows()\nlabeler.checkWindows()\n\njulia> labeler\nAnomalyBenchmark.Labeler(5×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n│ 3   │ 3     │ 2017-01-03T00:00:00 │\n│ 4   │ 4     │ 2017-01-04T00:00:00 │\n│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame\n│ Row │ timestamp           │ label │\n├─────┼─────────────────────┼───────┤\n│ 1   │ 2017-01-01T00:00:00 │ 0     │\n│ 2   │ 2017-01-02T00:00:00 │ 0     │\n│ 3   │ 2017-01-03T00:00:00 │ 1     │\n│ 4   │ 2017-01-04T00:00:00 │ 0     │\n│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.convertAnomalousWindowsToTimestamps-Union{Tuple{Array{Tuple{T, T}, 1}}, Tuple{T}} where T<:Dates.TimeType","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.convertAnomalousWindowsToTimestamps","text":"Returns an array that contains all anomalous timestamps given an array of start time and end time for every anomalous time windows\n\nArguments\n\nanomalousWindows::AbstractArray{Tuple{DateTime,DateTime},1} :   An array of start time and end time for every anomalous time windows.\n\nReturns\n\nArray{DateTime,1} that contains all anomalous timestamps.\n\nExamples\n\njulia> anomalousWindows = [(DateTime(2017, 1, 3, 10, 1), DateTime(2017, 1, 3, 10, 5)), (DateTime(2017, 1, 3, 10, 58), DateTime(2017, 1, 3, 11, 0))]\n2-element Array{Tuple{DateTime,DateTime},1}:\n (2017-01-03T10:01:00,2017-01-03T10:05:00)\n (2017-01-03T10:58:00,2017-01-03T11:00:00)\njulia> AnomalyBenchmark.convertAnomalousWindowsToTimestamps(anomalousWindows)\n8-element Array{DateTime,1}:\n 2017-01-03T10:01:00\n 2017-01-03T10:02:00\n 2017-01-03T10:03:00\n 2017-01-03T10:04:00\n 2017-01-03T10:05:00\n 2017-01-03T10:58:00\n 2017-01-03T10:59:00\n 2017-01-03T11:00:00\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.convertAnomalyScoresToDetections-Tuple{AbstractArray{Float64, N} where N, Float64}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.convertAnomalyScoresToDetections","text":"Convert anomaly scores (values between 0 and 1) to detections (binary values) given a threshold.\n\nArguments\n\nanomalyScores::AbstractArray{Float64} :   An array of anomaly scores.\n\nthreshold::Float64 :   The threshold for anomaly scores. If an anomaly score is greater than or equal to the threshold, the detection would be 1; otherwise, the detection would be 0.\n\nReturns\n\nArray{Int64,1} - An array of detections (1 = anomalous, 0 = normal).\n\nExamples\n\njulia> convertAnomalyScoresToDetections([0.3, 0.5, 0.7], 0.6)\n3-element Array{Int64,1}:\n 0\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getAlertTypes-Tuple{AnomalyBenchmark.Scorer, AbstractVector{var\"#s35\"} where var\"#s35\"<:Integer}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getAlertTypes","text":"Create list of windows for the data\n\nArguments\n\nscorer::Scorer\n\nlimits::Vector{Tuple{DateTime,DateTime}} :    All the window limits in tuple     form: (start time, end time).\n\nReturns\n\nAll the windows for the data of the scorer.\n\nExamples\n\ntimestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\njulia> scorer.getAlertTypes(predictions)\n5-element Array{AbstractString,1}:\n \"tn\"\n \"tp\"\n \"tn\"\n \"tn\"\n \"fp\"\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getClosestPrecedingWindow-Tuple{AnomalyBenchmark.Scorer, Int64}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getClosestPrecedingWindow","text":"Given a record index, find the closest preceding window.\n\nArguments\n\nscorer::Scorer\n\nindex::Int :    Index of a record.\n\nReturns\n\nWindow id for the last window preceding the given index.\n\nExamples\n\ntimestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict{AbstractString, Float64}(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\n\nscorer.getClosestPrecedingWindow(2)\n-1\n\nscorer.getClosestPrecedingWindow(4)\n1\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getFirstTruePositive-Tuple{AnomalyBenchmark.Window}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getFirstTruePositive","text":"Get the index of the first true positive within a window.\n\nArguments\n\nwindow::Window\n\nReturns\n\nIndex of the first true positive within a window. -1 if there are none.\n\nExamples\n\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5),\n    alerttype = [\"fp\", \"tp\", \"tp\", \"fn\", \"tn\"]\n)\nwindow = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)\njulia> window.getFirstTruePositive()\n2\n\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5),\n    alerttype = [\"fp\", \"fp\", \"fp\", \"fn\", \"tn\"]\n)\nwindow = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)\njulia> window.getFirstTruePositive()\n-1\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getProbationPeriod-Tuple{Float64, Int64}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getProbationPeriod","text":"Return the probationary period index given probation percentage and the length of the file.\n\nArguments\n\nprobationPercent::Float64 :   The percentage of predictions that won't be used for scoring.\n\nfileLength::Int :   The number of rows of the data file.\n\nReturns\n\n::Int64     If the file length is less than 5000, the probation period would be the probation percentage times the file length;     otherwise, it would be the probation percentage times 5,000.\n\nExamples\n\njulia> AnomalyBenchmark.getProbationPeriod(0.2, 4000)\n800\n\njulia> AnomalyBenchmark.getProbationPeriod(0.2, 10000)\n1000\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getScore-Tuple{AnomalyBenchmark.Scorer}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getScore","text":"Score the entire data and return a single floating point score. The position in a given window is calculated as the distance from the end of the window, normalized [-1,0]. I.e. positions -1.0 and 0.0 are at the very front and back of the anomaly window, respectively.\n\nFlat scoring option: If you'd like to run a flat scorer that does not apply the scaled sigmoid weighting, comment out the two scaledSigmoid() lines below, and uncomment the replacement lines to calculate thisTP and thisFP.\n\nArguments\n\nscorer::Scorer\n\nReturns\n\nTuple\n\nscores::AbstractVector{Float64} :    The score at each timestamp of the data.\n\nscorer.score::Float64 :    The score of the anomaly detection algorithm results.\n\nExamples\n\ntimestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict{AbstractString, Float64}(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\n\nscorer.getScore()\n([0.0,1.0,0.0,0.0,-0.9999092042625951],9.079573740489177e-5)\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getWindows-Tuple{AnomalyBenchmark.Labeler}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getWindows","text":"Takes all the true anomalies, as calculated by combineLabels(), and adds a standard window. Takes the anomaly windows and checks for overlap with both each other and with the probationary period. Overlapping windows are merged into a single window. Windows overlapping with the probationary period are deleted.\n\nArguments\n\nlabeler::Labeler\n\nExamples\n\nlabeler = Labeler(0.1, 0.15)\ntrueAnomalies = [DateTime(2017, 1, 3)]\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)\n)\n\nlabeler.setData(data)\nlabeler.setLabels(trueAnomalies)\nlabeler.getWindows()\n\njulia> labeler\nAnomalyBenchmark.Labeler(5×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n│ 3   │ 3     │ 2017-01-03T00:00:00 │\n│ 4   │ 4     │ 2017-01-04T00:00:00 │\n│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame\n│ Row │ timestamp           │ label │\n├─────┼─────────────────────┼───────┤\n│ 1   │ 2017-01-01T00:00:00 │ 0     │\n│ 2   │ 2017-01-02T00:00:00 │ 0     │\n│ 3   │ 2017-01-03T00:00:00 │ 1     │\n│ 4   │ 2017-01-04T00:00:00 │ 0     │\n│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.getWindows-Tuple{AnomalyBenchmark.Scorer, Vector{var\"#s34\"} where var\"#s34\"<:Union{Missing, Tuple{Dates.DateTime, Dates.DateTime}}}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.getWindows","text":"Create list of windows for the data\n\nArguments\n\nscorer::Scorer\n\nlimits::Vector{Tuple{DateTime,DateTime}} :    All the window limits in tuple     form: (start time, end time).\n\nReturns\n\nAll the windows for the data of the scorer.\n\nExamples\n\ntimestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict{AbstractString, Float64}(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\nscorer.getWindows(windowLimits)\n1-element Array{AnomalyBenchmark.Window,1}:\n AnomalyBenchmark.Window(1,2017-01-02T00:00:00,2017-01-03T00:00:00,2×4 DataFrames.DataFrame\n│ Row │ timestamp           │ label │ index │ alerttype │\n├─────┼─────────────────────┼───────┼───────┼───────────┤\n│ 1   │ 2017-01-02T00:00:00 │ 1     │ 2     │ \"tp\"      │\n│ 2   │ 2017-01-03T00:00:00 │ 0     │ 3     │ \"tn\"      │,[2,3],2,(anonymous function),(anonymous function))\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.normalizeScore-Tuple{AnomalyBenchmark.Scorer}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.normalizeScore","text":"Normalize the detectors' scores according to the baseline defined by the null detector, and print to the console. Function can only be called with the scoring step preceding it. The score is normalized by multiplying by 100 and dividing by perfect less the baseline, where the perfect score is the number of TPs possible.\n\nArguments\n\nscorer::Scorer\n\ntimestamps = collect(DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5))\npredictions = [0, 1, 0, 0, 1]\nlabels         = [0, 1, 0, 0, 0]\nwindowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]\ncostMatrix = Dict{AbstractString, Float64}(\n                \"tpWeight\" => 1.0,\n                \"fnWeight\" => 1.0,\n                \"fpWeight\" => 1.0\n            )\nprobationaryPeriod = 1\nscorer = AnomalyBenchmark.Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)\n\njulia> scorer.getScore()\n([0.0,1.0,0.0,0.0,-0.9999092042625951],9.079573740489177e-5)\n\njulia> scorer.normalizeScore()\n\nRunning score normalization step\n50.004539786870254\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.scaledSigmoid-Tuple{Float64}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.scaledSigmoid","text":"Return a scaled sigmoid function given a relative position within a labeled window.  The function is computed as follows:\n\nA relative position of -1.0 is the far left edge of the anomaly window and corresponds to S = 2*sigmoid(5) - 1.0 = 0.98661.  This is the earliest to be counted as a true positive.\n\nA relative position of -0.5 is halfway into the anomaly window and corresponds to S = 2*sigmoid(0.5*5) - 1.0 = 0.84828.\n\nA relative position of 0.0 consists of the right edge of the window and corresponds to S = 2*sigmoid(0) - 1 = 0.0.\n\nRelative positions > 0 correspond to false positives increasingly far away from the right edge of the window. A relative position of 1.0 is past the right  edge of the  window and corresponds to a score of 2*sigmoid(-5) - 1.0 = -0.98661.\n\nArguments\n\nrelativePositionInWindow::Float64 :    A relative position within a window calculated per the rules above.\n\nReturns\n\nFloat64 The scaled sigmoid score.\n\nExamples\n\njulia> AnomalyBenchmark.scaledSigmoid(-1.0)\n0.9866142981514305\n\njulia> AnomalyBenchmark.scaledSigmoid(-0.5)\n0.8482836399575131\n\njulia> AnomalyBenchmark.scaledSigmoid(0.0)\n0.0\n\njulia> AnomalyBenchmark.scaledSigmoid(1.0)\n-0.9866142981514303\n\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.scoreDataSet-Tuple{AnomalyBenchmark.Labeler, DataFrames.DataFrame, Vector{Dates.DateTime}, AbstractVector{var\"#s52\"} where var\"#s52\"<:Integer}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.scoreDataSet","text":"Compute AnomalyBenchmark scores given a detector's results, actual anomalies and a cost matrix.\n\nArguments\n\nlabeler::Labeler :    An object that stores and manipulates labels and windows for a given data set and its true anomalies.\n\ndata::DataFrame :    The whole data set with default columns timestamp.\n\ntrueAnomalies::Vector{DateTime} :    Timestamps of the ground truth anomalies.\n\npredictions::AbstractVector{<:Integer} :    Detector predictions of whether each record is anomalous or not.     predictions[1:probationaryPeriod-1] are ignored.\n\nOptional Arguments\n\ndetectorName::AbstractString=\"%\" :    The name of the anomaly detector.\n\nprofileName::AbstractString=\"standard\" :    The name of scoring profile. Each profile represents a cost matrix.\n\ncostMatrix::Dict{AbstractString, Float64} :    The cost matrix for the profile with the following keys:\n\nTrue positive (tp): detects the anomaly when the anomaly is present.\nFalse positive (fp): detects the anomaly when the anomaly is absent.\nTrue Negative (tn): does not detect the anomaly when the anomaly is absent.\nFalse Negative (fn): does not detect the anomaly when the anomaly is present.\n\nIf a costMatrix is given, it will be applied in place of the cost matrix provided by the profileName.\n\nReturns\n\nDict of values represents the anomaly detection benchmark for a given detector with the following keys:\n\nscorer :    The Scorer object for the detector.\n\ndetectorName :    The name of the anomaly detector.\n\nprofileName :    The name of scoring profile. If a customized costMatrix is provided, profileName is \"customized\".\n\nscorer.score :    The score of the anomaly detection algorithm results.\n\ncounts :    The counts of tp, fp, tn and fn. Only predictions after probationaryPeriod are counted.\n\nExamples\n\nlabeler = AnomalyBenchmark.Labeler(0.1, 0.15)\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)\n)\ntrueAnomalies = [DateTime(2017, 1, 2)]\npredictions = [0, 1, 0, 0, 0]\n\ndetectorName = \"tester\"\nprofileName = \"standard\"\n\njulia> AnomalyBenchmark.scoreDataSet(labeler, data, trueAnomalies, predictions, detectorName=detectorName, profileName=profileName)\nDict{ASCIIString,Any} with 5 entries:\n  \"detectorName\" => \"tester\"\n  \"counts\"       => Dict{AbstractString,Int64}(\"tp\"=>1,\"tn\"=>2,\"fn\"=>0,\"fp\"=>2)\n  \"score\"        => 0.78\n  \"profileName\"  => \"standard\"\n  \"scorer\"       => AnomalyBenchmark.Scorer(5×4 DataFrames.DataFrame…\n\nlabeler = AnomalyBenchmark.Labeler(0.1, 0.15)\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)\n)\ntrueAnomalies = [DateTime(2017, 1, 2)]\npredictions = [0, 1, 0, 0, 0]\n\ndetectorName = \"tester\"\ncostMatrix = Dict{AbstractString, Float64}(\"tpWeight\" => 1.0, \"fpWeight\" => 1.0, \"fnWeight\" => 1.0)\n\njulia> AnomalyBenchmark.scoreDataSet(labeler, data, trueAnomalies, predictions, detectorName=detectorName, costMatrix=costMatrix)\nDict{ASCIIString,Any} with 5 entries:\n  \"detectorName\" => \"tester\"\n  \"counts\"       => Dict{AbstractString,Int64}(\"tp\"=>1,\"tn\"=>4,\"fn\"=>0,\"fp\"=>2)\n  \"score\"        => -1.0\n  \"profileName\"  => \"customized\"\n  \"scorer\"       => AnomalyBenchmark.Scorer(5×4 DataFrames.DataFrame…\n\n\nanomalyScores = [0.7, 0.8, 0.5, 0.8, 0.9]\nthreshold = 0.75\n\njulia> AnomalyBenchmark.scoreDataSet(labeler, data, trueAnomalies, anomalyScores, threshold, detectorName=detectorName, costMatrix=costMatrix)\nDict{ASCIIString,Any} with 5 entries:\n  \"detectorName\" => \"tester\"\n  \"counts\"       => Dict{AbstractString,Int64}(\"tp\"=>1,\"tn\"=>2,\"fn\"=>0,\"fp\"=>2)\n  \"score\"        => -1.0\n  \"profileName\"  => \"customized\"\n  \"scorer\"       => AnomalyBenchmark.Scorer(5×4 DataFrames.DataFrame…\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.setData-Tuple{AnomalyBenchmark.Labeler, DataFrames.DataFrame}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.setData","text":"Set value for field data in a Labeler\n\nArguments\n\nlabeler::Labeler\n\ndata::DataFrame :    The whole data set with default columns timestamp.\n\nExamples\n\nlabeler = Labeler(0.1, 0.15)\ntrueAnomalies = [DateTime(2017, 1, 3)]\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1)::Day(1):DateTime(2017, 1, 5)\n)\n\nlabeler.setData(data)\njulia> labeler\nAnomalyBenchmark.Labeler(5×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n│ 3   │ 3     │ 2017-01-03T00:00:00 │\n│ 4   │ 4     │ 2017-01-04T00:00:00 │\n│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,0×0 DataFrames.DataFrame\n,Int64[],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.setLabels-Tuple{AnomalyBenchmark.Labeler, AbstractVector{Dates.DateTime}}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.setLabels","text":"Set value for field labels in a Labeler For each record there should be a 1 or a 0. A 1 implies this record is within an anomalous window.\n\nArguments\n\nlabeler::Labeler\n\ntrueAnomalies::AbstractArray{DateTime, 1} :    Timestamps of the ground truth anomalies.\n\nExamples\n\nlabeler = Labeler(0.1, 0.15)\ntrueAnomalies = [DateTime(2017, 1, 3)]\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)\n)\n\nlabeler.setData(data)\nlabeler.setLabels(trueAnomalies)\n\njulia> labeler\nAnomalyBenchmark.Labeler(5×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┤\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n│ 3   │ 3     │ 2017-01-03T00:00:00 │\n│ 4   │ 4     │ 2017-01-04T00:00:00 │\n│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame\n│ Row │ timestamp           │ label │\n├─────┼─────────────────────┼───────┤\n│ 1   │ 2017-01-01T00:00:00 │ 0     │\n│ 2   │ 2017-01-02T00:00:00 │ 0     │\n│ 3   │ 2017-01-03T00:00:00 │ 1     │\n│ 4   │ 2017-01-04T00:00:00 │ 0     │\n│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))\n\n\n\n\n\n\n","category":"method"},{"location":"index.html#AnomalyBenchmark.sigmoid-Tuple{Float64}","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.sigmoid","text":"Standard sigmoid function.\n\nfrac11+e^-x\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.show-Tuple{IO, AnomalyBenchmark.Window}","page":"AnomalyBenchmark.jl Documentation","title":"Base.show","text":"String representation of Window. For debugging.\n\nArguments\n\nwindow::Window\n\nExamples\n\ndata = DataFrame(\n    index = 1:5,\n    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)\n)\nwindow = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)\nwindow.repr()\nWINDOW id=1234, limits: [2017-01-01T00:00:00, 2017-01-02T00:00:00], length: 2\nwindow data:\n2×2 DataFrames.DataFrame\n│ Row │ index │ timestamp           │\n├─────┼───────┼─────────────────────┼\n│ 1   │ 1     │ 2017-01-01T00:00:00 │\n│ 2   │ 2     │ 2017-01-02T00:00:00 │\n\n\n\n\n\n","category":"method"},{"location":"index.html#Index","page":"AnomalyBenchmark.jl Documentation","title":"Index","text":"","category":"section"},{"location":"index.html","page":"AnomalyBenchmark.jl Documentation","title":"AnomalyBenchmark.jl Documentation","text":"","category":"page"}]
}
