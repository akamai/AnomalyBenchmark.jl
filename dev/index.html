<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NAB.jl Documentation · NAB.jl Documentation</title><meta name="title" content="NAB.jl Documentation · NAB.jl Documentation"/><meta property="og:title" content="NAB.jl Documentation · NAB.jl Documentation"/><meta property="twitter:title" content="NAB.jl Documentation · NAB.jl Documentation"/><meta name="description" content="Documentation for NAB.jl Documentation."/><meta property="og:description" content="Documentation for NAB.jl Documentation."/><meta property="twitter:description" content="Documentation for NAB.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">NAB.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">NAB.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">NAB.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">NAB.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/akamai/NAB.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/akamai/NAB.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="NAB.jl-Documentation"><a class="docs-heading-anchor" href="#NAB.jl-Documentation">NAB.jl Documentation</a><a id="NAB.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#NAB.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB" href="#NAB"><code>NAB</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>NAB.jl: Numenta Anomaly Benchmark for Evaluating Algorithms for Anomaly Detection in Streaming</strong></p><p>This is a Julia implementation of <a href="https://github.com/numenta/NAB">Numenta&#39;s NAB Python package for Anomaly Benchmarking</a>. The code is written from the ground up in Julia following the specifications of NAB.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/NAB.jl#L7-L12">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.Labeler" href="#NAB.Labeler"><code>NAB.Labeler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object to get labels and compute the window around each anomaly.</p><p><strong>Fields</strong></p><p><code>data::DataFrame</code> :    The whole data set with default columns <code>timestamp</code>.</p><p><code>windowSize::Float64</code> :    Estimated size of an anomaly window, as a ratio to the data set length.</p><p><code>probationaryPercent::Float64</code> :    The ratio of probationary period to the data set length.</p><p><code>labels::DataFrame</code> :    Ground truth for each record.     For each record there should be a 1 or a 0.     A 1 implies this record is within an anomalous window.</p><p><code>labelIndices::AbstractArray{Int, 1}</code> :    Indices of the true anomalies in labels</p><p><code>windows::AbstractArray{Tuple{DateTime,DateTime},1}</code> :    All the window limits in tuple     form: (start time, end time).</p><p><strong>Functions</strong></p><p><code>setData::Function</code> :    Set the dataset for <code>Labeler</code>.</p><p><code>setLabels::Function</code> :    Set the ground true labels from timestamps of true anomalies.</p><p><code>getWindows::Function</code> :    Call <code>applyWindows</code> and <code>checkWindows</code>.</p><p><code>applyWindows::Function</code> :    This takes all the true anomalies, and adds a standard window.     The window length is the class variable <code>windowSize</code>,     and the location is centered on the anomaly timestamp.</p><p><code>checkWindows::Function</code> :    This takes the anomaly windows and checks for overlap with both each other     and with the probationary period. Overlapping windows are merged into a     single window. Windows overlapping with the probationary period are deleted.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">function Labeler(windowSize::Float64, probationaryPercent::Float64)</code></pre><p><strong>Arguments</strong></p><p><code>windowSize::Float64</code> :    Estimated size of an anomaly window, as a ratio to the data set length.</p><p><code>probationaryPercent::Float64</code> :    The ratio of probationary period to the data set length.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Labeler(0.1, 0.15)
NAB.Labeler(0×0 DataFrames.DataFrame
,0.1,0.15,0×0 DataFrames.DataFrame
,Int64[],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L11-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.Scorer" href="#NAB.Scorer"><code>NAB.Scorer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object to score a data.</p><p><strong>Fields</strong></p><p><code>data::DataFrame</code> :    The whole data set with default columns <code>timestamp</code>, <code>label</code>, <code>index</code> and <code>alerttype</code>.</p><p><code>probationaryPeriod::Int</code> :    Row index after which predictions are scored.</p><p><code>costMatrix::Dict{AbstractString, Float64}</code> :    The cost matrix for the profile with the following keys:</p><ul><li>True positive (tpWeight): detects the anomaly when the anomaly is present.</li><li>False positive (fpWeight): detects the anomaly when the anomaly is absent.</li><li>True Negative (tnWeight): does not detect the anomaly when the anomaly is absent.</li><li>False Negative (fnWeight): does not detect the anomaly when the anomaly is present.</li></ul><p><code>totalCount::Int</code> :    The total count of labels.</p><p><code>counts::Dict{AbstractString, Int}</code> :    The counts of <code>tp</code>, <code>fp</code>, <code>tn</code> and <code>fn</code>. Only <code>predictions</code> after <code>probationaryPeriod</code> are counted.</p><p><code>score::Float64</code> :    The score of the anomaly detection algorithm results.</p><p><code>normalizedScore::Float64</code> :    The normalized score of the anomaly detection algorithm     such that the maximum possible is 100.0 (i.e. the perfect detector), and     a baseline of 0.0 is determined by the &quot;null&quot; detector (which makes no detections).</p><p><code>len::Int</code> :    The total count of predictions.</p><p><code>windows::Vector{Window}</code> :    The list of windows for the data.</p><p><code>windowLimits::Vector{Tuple{DateTime,DateTime}}</code> :    All the window limits in tuple     form: (start time, end time).</p><p><strong>Functions</strong></p><p><code>getWindows::Function</code> :    Create list of windows for the data.</p><p><code>getAlertTypes::Function</code> :    For each record, decide whether it is a <code>tp</code>, <code>fp</code>, <code>tn</code>, or <code>fn</code>. Populate     <code>counts</code> dictionary with the total number of records in each category.</p><p><code>getScore::Function</code> :    Score the entire data and return a single floating point score.</p><p><code>getClosestPrecedingWindow::Function</code> :    Given a record index, find the closest preceding window.</p><p><code>normalizeScore::Function</code> :    Normalize the detectors&#39; scores according to the baseline defined by the null detector.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Scorer(
        timestamps::Vector{DateTime},
        predictions::AbstractVector{&lt;:Integer},
        labels::AbstractVector{&lt;:Integer},
        windowLimits::Vector{Tuple{DateTime,DateTime}},
        costMatrix::Dict{&lt;:AbstractString, Float64},
        probationaryPeriod::Int
    )</code></pre><p><strong>Arguments</strong></p><p><code>timestamps::Vector{DateTime}</code> :    Timestamps in the data.</p><p><code>predictions::AbstractVector{&lt;:Integer}</code> :    Detector predictions of whether each record is anomalous or not.     <code>predictions[1:probationaryPeriod-1]</code> are ignored.</p><p><code>labels::AbstractVector{Integer}</code> :    Ground truth for each record.     For each record there should be a 1 or a 0.     A 1 implies this record is within an anomalous window.</p><p><code>windowLimits::Vector{Tuple{DateTime,DateTime}}</code> :    All the window limits in tuple     form: (start time, end time).</p><p><code>costMatrix::Dict{AbstractString, Float64}</code> :    The cost matrix for the profile with the following keys:</p><ul><li>True positive (tpWeight): detects the anomaly when the anomaly is present.</li><li>False positive (fpWeight): detects the anomaly when the anomaly is absent.</li><li>True Negative (tnWeight): does not detect the anomaly when the anomaly is absent.</li><li>False Negative (fnWeight): does not detect the anomaly when the anomaly is present.</li></ul><p><code>probationaryPeriod::Int</code> :    Row index after which predictions are scored.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict{AbstractString, Float64}(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)
NAB.Scorer(5×4 DataFrames.DataFrame
│ Row │ timestamp           │ label │ index │ alerttype │
├─────┼─────────────────────┼───────┼───────┼───────────┤
│ 1   │ 2017-01-01T00:00:00 │ 0     │ 1     │ &quot;tn&quot;      │
│ 2   │ 2017-01-02T00:00:00 │ 1     │ 2     │ &quot;tp&quot;      │
│ 3   │ 2017-01-03T00:00:00 │ 0     │ 3     │ &quot;tn&quot;      │
│ 4   │ 2017-01-04T00:00:00 │ 0     │ 4     │ &quot;tn&quot;      │
│ 5   │ 2017-01-05T00:00:00 │ 0     │ 5     │ &quot;fp&quot;      │,1,Dict(:tpWeight=&gt;1.0,:fnWeight=&gt;1.0,:fpWeight=&gt;1.0),5,
Dict{AbstractString,Int64}(&quot;tp&quot;=&gt;1,&quot;tn&quot;=&gt;3,&quot;fn&quot;=&gt;0,&quot;fp&quot;=&gt;1),0.0,5,[NAB.Window(1,2017-01-02T00:00:00,2017-01-03T00:00:00,2×4 DataFrames.DataFrame
│ Row │ timestamp           │ label │ index │ alerttype │
├─────┼─────────────────────┼───────┼───────┼───────────┤
│ 1   │ 2017-01-02T00:00:00 │ 1     │ 2     │ &quot;tp&quot;      │
│ 2   │ 2017-01-03T00:00:00 │ 0     │ 3     │ &quot;tn&quot;      │,[2,3],2,(anonymous function),(anonymous function))],(anonymous function),(anonymous function),(anonymous function),(anonymous function))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L177-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.Window" href="#NAB.Window"><code>NAB.Window</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Immutable object to store a single window in a data. Each window represents a range of data points that is centered around a ground truth anomaly label.</p><p><strong>Fields</strong></p><p><code>id::Int</code> :    The identifier of the <code>Window</code>.</p><p><code>t1::DateTime</code> :    The start time of the <code>Window</code>.</p><p><code>t2::DateTime</code> :    The end time of the <code>Window</code>.</p><p><code>window::DataFrame</code> :    The data within the <code>Window</code>.</p><p><code>indices::AbstractArray</code> :    The indices of the <code>Window</code> in the data.</p><p><code>len::Int</code> :    The length of the <code>Window</code>.</p><p><strong>Functions</strong></p><p><code>repr::Function</code> :    String representation of <code>Window</code>. For debugging.</p><p><code>getFirstTruePositive::Function</code> :    Get the index of the first true positive within a window.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Window(windowId::Int, limits::Tuple{DateTime, DateTime}, data::DataFrame)</code></pre><p><strong>Arguments</strong></p><p><code>windowId::Int</code> :    An integer id for the <code>Window</code>.</p><p><code>limits::Tuple{DateTime, DateTime}</code> :    The start time and end time of the <code>Window</code>.</p><p><code>data::DataFrame</code> :    The whole data set with default columns <code>index</code> and <code>timestamp</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)
)
window = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)
NAB.Window(1234,2017-01-01T00:00:00,2017-01-02T00:00:00,2×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │,[1,2],2,(anonymous function),(anonymous function))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L12-L74">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, NAB.Window}" href="#Base.show-Tuple{IO, NAB.Window}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>String representation of <code>Window</code>. For debugging.</p><p><strong>Arguments</strong></p><p><code>window::Window</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)
)
window = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)
window.repr()
WINDOW id=1234, limits: [2017-01-01T00:00:00, 2017-01-02T00:00:00], length: 2
window data:
2×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┼
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L104-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.applyWindows-Tuple{NAB.Labeler}" href="#NAB.applyWindows-Tuple{NAB.Labeler}"><code>NAB.applyWindows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes all the true anomalies, as calculated by combineLabels(), and adds a standard window.</p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = Labeler(0.1, 0.15)
trueAnomalies = [DateTime(2017, 1, 3)]
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)
)

labeler.setData(data)
labeler.setLabels(trueAnomalies)
labeler.applyWindows()

julia&gt; labeler
NAB.Labeler(5×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │
│ 3   │ 3     │ 2017-01-03T00:00:00 │
│ 4   │ 4     │ 2017-01-04T00:00:00 │
│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame
│ Row │ timestamp           │ label │
├─────┼─────────────────────┼───────┤
│ 1   │ 2017-01-01T00:00:00 │ 0     │
│ 2   │ 2017-01-02T00:00:00 │ 0     │
│ 3   │ 2017-01-03T00:00:00 │ 1     │
│ 4   │ 2017-01-04T00:00:00 │ 0     │
│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L261-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.checkWindows-Tuple{NAB.Labeler}" href="#NAB.checkWindows-Tuple{NAB.Labeler}"><code>NAB.checkWindows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes the anomaly windows and checks for overlap with both each other and with the probationary period. Overlapping windows are merged into a single window. Windows overlapping with the probationary period are deleted.</p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = Labeler(0.1, 0.15)
trueAnomalies = [DateTime(2017, 1, 3)]
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)
)

labeler.setData(data)
labeler.setLabels(trueAnomalies)
labeler.applyWindows()
labeler.checkWindows()

julia&gt; labeler
NAB.Labeler(5×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │
│ 3   │ 3     │ 2017-01-03T00:00:00 │
│ 4   │ 4     │ 2017-01-04T00:00:00 │
│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame
│ Row │ timestamp           │ label │
├─────┼─────────────────────┼───────┤
│ 1   │ 2017-01-01T00:00:00 │ 0     │
│ 2   │ 2017-01-02T00:00:00 │ 0     │
│ 3   │ 2017-01-03T00:00:00 │ 1     │
│ 4   │ 2017-01-04T00:00:00 │ 0     │
│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L323-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.convertAnomalousWindowsToTimestamps-Union{Tuple{Array{Tuple{T, T}, 1}}, Tuple{T}} where T&lt;:Dates.TimeType" href="#NAB.convertAnomalousWindowsToTimestamps-Union{Tuple{Array{Tuple{T, T}, 1}}, Tuple{T}} where T&lt;:Dates.TimeType"><code>NAB.convertAnomalousWindowsToTimestamps</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns an array that contains all anomalous timestamps given an array of start time and end time for every anomalous time windows</p><p><strong>Arguments</strong></p><p><code>anomalousWindows::AbstractArray{Tuple{DateTime,DateTime},1}</code> :   An array of start time and end time for every anomalous time windows.</p><p><strong>Returns</strong></p><p><code>Array{DateTime,1}</code> that contains all anomalous timestamps.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; anomalousWindows = [(DateTime(2017, 1, 3, 10, 1), DateTime(2017, 1, 3, 10, 5)), (DateTime(2017, 1, 3, 10, 58), DateTime(2017, 1, 3, 11, 0))]
2-element Array{Tuple{DateTime,DateTime},1}:
 (2017-01-03T10:01:00,2017-01-03T10:05:00)
 (2017-01-03T10:58:00,2017-01-03T11:00:00)
julia&gt; NAB.convertAnomalousWindowsToTimestamps(anomalousWindows)
8-element Array{DateTime,1}:
 2017-01-03T10:01:00
 2017-01-03T10:02:00
 2017-01-03T10:03:00
 2017-01-03T10:04:00
 2017-01-03T10:05:00
 2017-01-03T10:58:00
 2017-01-03T10:59:00
 2017-01-03T11:00:00</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/util.jl#L77-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.convertAnomalyScoresToDetections-Tuple{AbstractArray{Float64, N} where N, Float64}" href="#NAB.convertAnomalyScoresToDetections-Tuple{AbstractArray{Float64, N} where N, Float64}"><code>NAB.convertAnomalyScoresToDetections</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert anomaly scores (values between 0 and 1) to detections (binary values) given a threshold.</p><p><strong>Arguments</strong></p><p><code>anomalyScores::AbstractArray{Float64}</code> :   An array of anomaly scores.</p><p><code>threshold::Float64</code> :   The threshold for anomaly scores. If an anomaly score is greater than or equal to the threshold, the detection would be 1; otherwise, the detection would be 0.</p><p><strong>Returns</strong></p><p><code>Array{Int64,1}</code> - An array of detections (1 = anomalous, 0 = normal).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; convertAnomalyScoresToDetections([0.3, 0.5, 0.7], 0.6)
3-element Array{Int64,1}:
 0
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/util.jl#L44-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getAlertTypes-Tuple{NAB.Scorer, AbstractVector{var&quot;#s35&quot;} where var&quot;#s35&quot;&lt;:Integer}" href="#NAB.getAlertTypes-Tuple{NAB.Scorer, AbstractVector{var&quot;#s35&quot;} where var&quot;#s35&quot;&lt;:Integer}"><code>NAB.getAlertTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create list of windows for the data</p><p><strong>Arguments</strong></p><p><code>scorer::Scorer</code></p><p><code>limits::Vector{Tuple{DateTime,DateTime}}</code> :    All the window limits in tuple     form: (start time, end time).</p><p><strong>Returns</strong></p><p>All the windows for the data of the scorer.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)
julia&gt; scorer.getAlertTypes(predictions)
5-element Array{AbstractString,1}:
 &quot;tn&quot;
 &quot;tp&quot;
 &quot;tn&quot;
 &quot;tn&quot;
 &quot;fp&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L419-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getClosestPrecedingWindow-Tuple{NAB.Scorer, Int64}" href="#NAB.getClosestPrecedingWindow-Tuple{NAB.Scorer, Int64}"><code>NAB.getClosestPrecedingWindow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a record index, find the closest preceding window.</p><p><strong>Arguments</strong></p><p><code>scorer::Scorer</code></p><p><code>index::Int</code> :    Index of a record.</p><p><strong>Returns</strong></p><p>Window id for the last window preceding the given index.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict{AbstractString, Float64}(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)

scorer.getClosestPrecedingWindow(2)
-1

scorer.getClosestPrecedingWindow(4)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L579-L613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getFirstTruePositive-Tuple{NAB.Window}" href="#NAB.getFirstTruePositive-Tuple{NAB.Window}"><code>NAB.getFirstTruePositive</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the index of the first true positive within a window.</p><p><strong>Arguments</strong></p><p><code>window::Window</code></p><p><strong>Returns</strong></p><p>Index of the first true positive within a window. -1 if there are none.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5),
    alerttype = [&quot;fp&quot;, &quot;tp&quot;, &quot;tp&quot;, &quot;fn&quot;, &quot;tn&quot;]
)
window = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)
julia&gt; window.getFirstTruePositive()
2

data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5),
    alerttype = [&quot;fp&quot;, &quot;fp&quot;, &quot;fp&quot;, &quot;fn&quot;, &quot;tn&quot;]
)
window = Window(1234, (DateTime(2017, 1, 1), DateTime(2017, 1, 2)), data)
julia&gt; window.getFirstTruePositive()
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L133-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getProbationPeriod-Tuple{Float64, Int64}" href="#NAB.getProbationPeriod-Tuple{Float64, Int64}"><code>NAB.getProbationPeriod</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the probationary period index given probation percentage and the length of the file.</p><p><strong>Arguments</strong></p><p><code>probationPercent::Float64</code> :   The percentage of predictions that won&#39;t be used for scoring.</p><p><code>fileLength::Int</code> :   The number of rows of the data file.</p><p><strong>Returns</strong></p><p><code>::Int64</code>     If the file length is less than 5000, the probation period would be the probation percentage times the file length;     otherwise, it would be the probation percentage times 5,000.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; NAB.getProbationPeriod(0.2, 4000)
800

julia&gt; NAB.getProbationPeriod(0.2, 10000)
1000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/util.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getScore-Tuple{NAB.Scorer}" href="#NAB.getScore-Tuple{NAB.Scorer}"><code>NAB.getScore</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Score the entire data and return a single floating point score. The position in a given window is calculated as the distance from the end of the window, normalized [-1,0]. I.e. positions -1.0 and 0.0 are at the very front and back of the anomaly window, respectively.</p><p>Flat scoring option: If you&#39;d like to run a flat scorer that does not apply the scaled sigmoid weighting, comment out the two <code>scaledSigmoid()</code> lines below, and uncomment the replacement lines to calculate <code>thisTP</code> and <code>thisFP</code>.</p><p><strong>Arguments</strong></p><p><code>scorer::Scorer</code></p><p><strong>Returns</strong></p><p><code>Tuple</code></p><p><code>scores::AbstractVector{Float64}</code> :    The score at each timestamp of the data.</p><p><code>scorer.score::Float64</code> :    The score of the anomaly detection algorithm results.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict{AbstractString, Float64}(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)

scorer.getScore()
([0.0,1.0,0.0,0.0,-0.9999092042625951],9.079573740489177e-5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L481-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getWindows-Tuple{NAB.Labeler}" href="#NAB.getWindows-Tuple{NAB.Labeler}"><code>NAB.getWindows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Takes all the true anomalies, as calculated by combineLabels(), and adds a standard window. Takes the anomaly windows and checks for overlap with both each other and with the probationary period. Overlapping windows are merged into a single window. Windows overlapping with the probationary period are deleted.</p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = Labeler(0.1, 0.15)
trueAnomalies = [DateTime(2017, 1, 3)]
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)
)

labeler.setData(data)
labeler.setLabels(trueAnomalies)
labeler.getWindows()

julia&gt; labeler
NAB.Labeler(5×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │
│ 3   │ 3     │ 2017-01-03T00:00:00 │
│ 4   │ 4     │ 2017-01-04T00:00:00 │
│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame
│ Row │ timestamp           │ label │
├─────┼─────────────────────┼───────┤
│ 1   │ 2017-01-01T00:00:00 │ 0     │
│ 2   │ 2017-01-02T00:00:00 │ 0     │
│ 3   │ 2017-01-03T00:00:00 │ 1     │
│ 4   │ 2017-01-04T00:00:00 │ 0     │
│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],[(2017-01-03T00:00:00,2017-01-03T00:00:00)],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L211-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.getWindows-Tuple{NAB.Scorer, Vector{var&quot;#s34&quot;} where var&quot;#s34&quot;&lt;:Union{Missing, Tuple{Dates.DateTime, Dates.DateTime}}}" href="#NAB.getWindows-Tuple{NAB.Scorer, Vector{var&quot;#s34&quot;} where var&quot;#s34&quot;&lt;:Union{Missing, Tuple{Dates.DateTime, Dates.DateTime}}}"><code>NAB.getWindows</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create list of windows for the data</p><p><strong>Arguments</strong></p><p><code>scorer::Scorer</code></p><p><code>limits::Vector{Tuple{DateTime,DateTime}}</code> :    All the window limits in tuple     form: (start time, end time).</p><p><strong>Returns</strong></p><p>All the windows for the data of the scorer.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict{AbstractString, Float64}(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)
scorer.getWindows(windowLimits)
1-element Array{NAB.Window,1}:
 NAB.Window(1,2017-01-02T00:00:00,2017-01-03T00:00:00,2×4 DataFrames.DataFrame
│ Row │ timestamp           │ label │ index │ alerttype │
├─────┼─────────────────────┼───────┼───────┼───────────┤
│ 1   │ 2017-01-02T00:00:00 │ 1     │ 2     │ &quot;tp&quot;      │
│ 2   │ 2017-01-03T00:00:00 │ 0     │ 3     │ &quot;tn&quot;      │,[2,3],2,(anonymous function),(anonymous function))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L374-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.normalizeScore-Tuple{NAB.Scorer}" href="#NAB.normalizeScore-Tuple{NAB.Scorer}"><code>NAB.normalizeScore</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Normalize the detectors&#39; scores according to the baseline defined by the null detector, and print to the console. Function can only be called with the scoring step preceding it. The score is normalized by multiplying by 100 and dividing by perfect less the baseline, where the perfect score is the number of TPs possible.</p><p><strong>Arguments</strong></p><p><code>scorer::Scorer</code></p><pre><code class="language-julia hljs">timestamps = collect(DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5))
predictions = [0, 1, 0, 0, 1]
labels         = [0, 1, 0, 0, 0]
windowLimits = [(DateTime(2017, 1, 2), DateTime(2017, 1, 3))]
costMatrix = Dict{AbstractString, Float64}(
                &quot;tpWeight&quot; =&gt; 1.0,
                &quot;fnWeight&quot; =&gt; 1.0,
                &quot;fpWeight&quot; =&gt; 1.0
            )
probationaryPeriod = 1
scorer = NAB.Scorer(timestamps, predictions, labels, windowLimits, costMatrix, probationaryPeriod)

julia&gt; scorer.getScore()
([0.0,1.0,0.0,0.0,-0.9999092042625951],9.079573740489177e-5)

julia&gt; scorer.normalizeScore()

Running score normalization step
50.004539786870254</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L878-L910">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.scaledSigmoid-Tuple{Float64}" href="#NAB.scaledSigmoid-Tuple{Float64}"><code>NAB.scaledSigmoid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a scaled sigmoid function given a relative position within a labeled window.  The function is computed as follows:</p><p>A relative position of -1.0 is the far left edge of the anomaly window and corresponds to <code>S = 2*sigmoid(5) - 1.0 = 0.98661</code>.  This is the earliest to be counted as a true positive.</p><p>A relative position of -0.5 is halfway into the anomaly window and corresponds to <code>S = 2*sigmoid(0.5*5) - 1.0 = 0.84828</code>.</p><p>A relative position of 0.0 consists of the right edge of the window and corresponds to <code>S = 2*sigmoid(0) - 1 = 0.0</code>.</p><p>Relative positions &gt; 0 correspond to false positives increasingly far away from the right edge of the window. A relative position of 1.0 is past the right  edge of the  window and corresponds to a score of <code>2*sigmoid(-5) - 1.0 = -0.98661</code>.</p><p><strong>Arguments</strong></p><p><code>relativePositionInWindow::Float64</code> :    A relative position within a window calculated per the rules above.</p><p><strong>Returns</strong></p><p><code>Float64</code> The scaled sigmoid score.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; NAB.scaledSigmoid(-1.0)
0.9866142981514305

julia&gt; NAB.scaledSigmoid(-0.5)
0.8482836399575131

julia&gt; NAB.scaledSigmoid(0.0)
0.0

julia&gt; NAB.scaledSigmoid(1.0)
-0.9866142981514303
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L642-L685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.scoreDataSet-Tuple{NAB.Labeler, DataFrames.DataFrame, Vector{Dates.DateTime}, AbstractVector{var&quot;#s52&quot;} where var&quot;#s52&quot;&lt;:Integer}" href="#NAB.scoreDataSet-Tuple{NAB.Labeler, DataFrames.DataFrame, Vector{Dates.DateTime}, AbstractVector{var&quot;#s52&quot;} where var&quot;#s52&quot;&lt;:Integer}"><code>NAB.scoreDataSet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute NAB scores given a detector&#39;s results, actual anomalies and a cost matrix.</p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code> :    An object that stores and manipulates labels and windows for a given data set and its true anomalies.</p><p><code>data::DataFrame</code> :    The whole data set with default columns <code>timestamp</code>.</p><p><code>trueAnomalies::Vector{DateTime}</code> :    Timestamps of the ground truth anomalies.</p><p><code>predictions::AbstractVector{&lt;:Integer}</code> :    Detector predictions of whether each record is anomalous or not.     <code>predictions[1:probationaryPeriod-1]</code> are ignored.</p><p><strong>Optional Arguments</strong></p><p><code>detectorName::AbstractString=&quot;%&quot;</code> :    The name of the anomaly detector.</p><p><code>profileName::AbstractString=&quot;standard&quot;</code> :    The name of scoring profile. Each profile represents a cost matrix.</p><p><code>costMatrix::Dict{AbstractString, Float64}</code> :    The cost matrix for the profile with the following keys:</p><ul><li>True positive (tp): detects the anomaly when the anomaly is present.</li><li>False positive (fp): detects the anomaly when the anomaly is absent.</li><li>True Negative (tn): does not detect the anomaly when the anomaly is absent.</li><li>False Negative (fn): does not detect the anomaly when the anomaly is present.</li></ul><p>If a <code>costMatrix</code> is given, it will be applied in place of the cost matrix provided by the <code>profileName</code>.</p><p><strong>Returns</strong></p><p><code>Dict</code> of values represents the anomaly detection benchmark for a given detector with the following keys:</p><p><code>scorer</code> :    The <code>Scorer</code> object for the detector.</p><p><code>detectorName</code> :    The name of the anomaly detector.</p><p><code>profileName</code> :    The name of scoring profile. If a customized <code>costMatrix</code> is provided, <code>profileName</code> is <code>&quot;customized&quot;</code>.</p><p><code>scorer.score</code> :    The score of the anomaly detection algorithm results.</p><p><code>counts</code> :    The counts of <code>tp</code>, <code>fp</code>, <code>tn</code> and <code>fn</code>. Only <code>predictions</code> after <code>probationaryPeriod</code> are counted.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = NAB.Labeler(0.1, 0.15)
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)
)
trueAnomalies = [DateTime(2017, 1, 2)]
predictions = [0, 1, 0, 0, 0]

detectorName = &quot;tester&quot;
profileName = &quot;standard&quot;

julia&gt; NAB.scoreDataSet(labeler, data, trueAnomalies, predictions, detectorName=detectorName, profileName=profileName)
Dict{ASCIIString,Any} with 5 entries:
  &quot;detectorName&quot; =&gt; &quot;tester&quot;
  &quot;counts&quot;       =&gt; Dict{AbstractString,Int64}(&quot;tp&quot;=&gt;1,&quot;tn&quot;=&gt;2,&quot;fn&quot;=&gt;0,&quot;fp&quot;=&gt;2)
  &quot;score&quot;        =&gt; 0.78
  &quot;profileName&quot;  =&gt; &quot;standard&quot;
  &quot;scorer&quot;       =&gt; NAB.Scorer(5×4 DataFrames.DataFrame…

labeler = NAB.Labeler(0.1, 0.15)
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):Day(1):DateTime(2017, 1, 5)
)
trueAnomalies = [DateTime(2017, 1, 2)]
predictions = [0, 1, 0, 0, 0]

detectorName = &quot;tester&quot;
costMatrix = Dict{AbstractString, Float64}(&quot;tpWeight&quot; =&gt; 1.0, &quot;fpWeight&quot; =&gt; 1.0, &quot;fnWeight&quot; =&gt; 1.0)

julia&gt; NAB.scoreDataSet(labeler, data, trueAnomalies, predictions, detectorName=detectorName, costMatrix=costMatrix)
Dict{ASCIIString,Any} with 5 entries:
  &quot;detectorName&quot; =&gt; &quot;tester&quot;
  &quot;counts&quot;       =&gt; Dict{AbstractString,Int64}(&quot;tp&quot;=&gt;1,&quot;tn&quot;=&gt;4,&quot;fn&quot;=&gt;0,&quot;fp&quot;=&gt;2)
  &quot;score&quot;        =&gt; -1.0
  &quot;profileName&quot;  =&gt; &quot;customized&quot;
  &quot;scorer&quot;       =&gt; NAB.Scorer(5×4 DataFrames.DataFrame…


anomalyScores = [0.7, 0.8, 0.5, 0.8, 0.9]
threshold = 0.75

julia&gt; NAB.scoreDataSet(labeler, data, trueAnomalies, anomalyScores, threshold, detectorName=detectorName, costMatrix=costMatrix)
Dict{ASCIIString,Any} with 5 entries:
  &quot;detectorName&quot; =&gt; &quot;tester&quot;
  &quot;counts&quot;       =&gt; Dict{AbstractString,Int64}(&quot;tp&quot;=&gt;1,&quot;tn&quot;=&gt;2,&quot;fn&quot;=&gt;0,&quot;fp&quot;=&gt;2)
  &quot;score&quot;        =&gt; -1.0
  &quot;profileName&quot;  =&gt; &quot;customized&quot;
  &quot;scorer&quot;       =&gt; NAB.Scorer(5×4 DataFrames.DataFrame…</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L697-L806">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.setData-Tuple{NAB.Labeler, DataFrames.DataFrame}" href="#NAB.setData-Tuple{NAB.Labeler, DataFrames.DataFrame}"><code>NAB.setData</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set value for field <code>data</code> in a <code>Labeler</code></p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code></p><p><code>data::DataFrame</code> :    The whole data set with default columns <code>timestamp</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = Labeler(0.1, 0.15)
trueAnomalies = [DateTime(2017, 1, 3)]
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1)::Day(1):DateTime(2017, 1, 5)
)

labeler.setData(data)
julia&gt; labeler
NAB.Labeler(5×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │
│ 3   │ 3     │ 2017-01-03T00:00:00 │
│ 4   │ 4     │ 2017-01-04T00:00:00 │
│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,0×0 DataFrames.DataFrame
,Int64[],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L117-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.setLabels-Tuple{NAB.Labeler, AbstractVector{Dates.DateTime}}" href="#NAB.setLabels-Tuple{NAB.Labeler, AbstractVector{Dates.DateTime}}"><code>NAB.setLabels</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set value for field <code>labels</code> in a <code>Labeler</code> For each record there should be a 1 or a 0. A 1 implies this record is within an anomalous window.</p><p><strong>Arguments</strong></p><p><code>labeler::Labeler</code></p><p><code>trueAnomalies::AbstractArray{DateTime, 1}</code> :    Timestamps of the ground truth anomalies.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">labeler = Labeler(0.1, 0.15)
trueAnomalies = [DateTime(2017, 1, 3)]
data = DataFrame(
    index = 1:5,
    timestamp = DateTime(2017, 1, 1):DateTime(2017, 1, 5)
)

labeler.setData(data)
labeler.setLabels(trueAnomalies)

julia&gt; labeler
NAB.Labeler(5×2 DataFrames.DataFrame
│ Row │ index │ timestamp           │
├─────┼───────┼─────────────────────┤
│ 1   │ 1     │ 2017-01-01T00:00:00 │
│ 2   │ 2     │ 2017-01-02T00:00:00 │
│ 3   │ 3     │ 2017-01-03T00:00:00 │
│ 4   │ 4     │ 2017-01-04T00:00:00 │
│ 5   │ 5     │ 2017-01-05T00:00:00 │,0.1,0.15,5×2 DataFrames.DataFrame
│ Row │ timestamp           │ label │
├─────┼─────────────────────┼───────┤
│ 1   │ 2017-01-01T00:00:00 │ 0     │
│ 2   │ 2017-01-02T00:00:00 │ 0     │
│ 3   │ 2017-01-03T00:00:00 │ 1     │
│ 4   │ 2017-01-04T00:00:00 │ 0     │
│ 5   │ 2017-01-05T00:00:00 │ 0     │,[3],Tuple{DateTime,DateTime}[],(anonymous function),(anonymous function),(anonymous function),(anonymous function),(anonymous function))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/labeler.jl#L158-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NAB.sigmoid-Tuple{Float64}" href="#NAB.sigmoid-Tuple{Float64}"><code>NAB.sigmoid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard sigmoid function.</p><p class="math-container">\[\frac{1}{1+e^{-x}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akamai/NAB.jl/blob/b93129f3db53ac6e6f018ae85177d6d99101436e/src/scorer.jl#L631-L635">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="index.html#NAB"><code>NAB</code></a></li><li><a href="index.html#NAB.Labeler"><code>NAB.Labeler</code></a></li><li><a href="index.html#NAB.Scorer"><code>NAB.Scorer</code></a></li><li><a href="index.html#NAB.Window"><code>NAB.Window</code></a></li><li><a href="index.html#Base.show-Tuple{IO, NAB.Window}"><code>Base.show</code></a></li><li><a href="index.html#NAB.applyWindows-Tuple{NAB.Labeler}"><code>NAB.applyWindows</code></a></li><li><a href="index.html#NAB.checkWindows-Tuple{NAB.Labeler}"><code>NAB.checkWindows</code></a></li><li><a href="index.html#NAB.convertAnomalousWindowsToTimestamps-Union{Tuple{Array{Tuple{T, T}, 1}}, Tuple{T}} where T&lt;:Dates.TimeType"><code>NAB.convertAnomalousWindowsToTimestamps</code></a></li><li><a href="index.html#NAB.convertAnomalyScoresToDetections-Tuple{AbstractArray{Float64, N} where N, Float64}"><code>NAB.convertAnomalyScoresToDetections</code></a></li><li><a href="index.html#NAB.getAlertTypes-Tuple{NAB.Scorer, AbstractVector{var&quot;#s35&quot;} where var&quot;#s35&quot;&lt;:Integer}"><code>NAB.getAlertTypes</code></a></li><li><a href="index.html#NAB.getClosestPrecedingWindow-Tuple{NAB.Scorer, Int64}"><code>NAB.getClosestPrecedingWindow</code></a></li><li><a href="index.html#NAB.getFirstTruePositive-Tuple{NAB.Window}"><code>NAB.getFirstTruePositive</code></a></li><li><a href="index.html#NAB.getProbationPeriod-Tuple{Float64, Int64}"><code>NAB.getProbationPeriod</code></a></li><li><a href="index.html#NAB.getScore-Tuple{NAB.Scorer}"><code>NAB.getScore</code></a></li><li><a href="index.html#NAB.getWindows-Tuple{NAB.Scorer, Vector{var&quot;#s34&quot;} where var&quot;#s34&quot;&lt;:Union{Missing, Tuple{Dates.DateTime, Dates.DateTime}}}"><code>NAB.getWindows</code></a></li><li><a href="index.html#NAB.getWindows-Tuple{NAB.Labeler}"><code>NAB.getWindows</code></a></li><li><a href="index.html#NAB.normalizeScore-Tuple{NAB.Scorer}"><code>NAB.normalizeScore</code></a></li><li><a href="index.html#NAB.scaledSigmoid-Tuple{Float64}"><code>NAB.scaledSigmoid</code></a></li><li><a href="index.html#NAB.scoreDataSet-Tuple{NAB.Labeler, DataFrames.DataFrame, Vector{Dates.DateTime}, AbstractVector{var&quot;#s52&quot;} where var&quot;#s52&quot;&lt;:Integer}"><code>NAB.scoreDataSet</code></a></li><li><a href="index.html#NAB.setData-Tuple{NAB.Labeler, DataFrames.DataFrame}"><code>NAB.setData</code></a></li><li><a href="index.html#NAB.setLabels-Tuple{NAB.Labeler, AbstractVector{Dates.DateTime}}"><code>NAB.setLabels</code></a></li><li><a href="index.html#NAB.sigmoid-Tuple{Float64}"><code>NAB.sigmoid</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Wednesday 20 September 2023 14:54">Wednesday 20 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
